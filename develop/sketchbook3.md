



///// start the beautiful game crypto

/// content goes here

At the time of writing, this may sound like science fiction. I will even borrow a definition from the imagination Iain M. Banks., Sublimation. In Banks's universe the Sublimed are alien civilizations which have left the known dimensions of space-time behind to take up residence in higher dimensions.

Envision a future wherein the next cycle of global economic instability leads information age companies to index their value upon cryptocurrency as opposed to the U.S. dollar. An act of self-preservation, decided upon in microsecond consensus between respective corporate AI. There is no industry more predisposed to do so. A calculated departure from contemporary markets, the central banking system and fiat currency, another parallel world.

The very presence of information age companies in an industrial age economy is causing that same global economic instability. Lift the lid on this Schroedinger's cat, and you will discover she has had kittens.

If a single error in software programming can come so close to ending the world, line by line deliberate acts of software engineering may create a new one. The butterfly effect of Satoshi Nakamoto, The cathedral gives way to the bazaar, For want of a nail:

>For want of a nail the shoe was lost.

>For want of a shoe the horse was lost.

>For want of a horse the rider was lost.

>For want of a rider the message was lost.

>For want of a message the battle was lost.

>For want of a battle the kingdom was lost.

>And all for the want of a horseshoe nail.

It would be the establishment of a new global economy â€” Dot-Com bubble, the Dot-Com expansion, and the ultimate Dot-Com sublimation. 

Sublimed Unicorns.

Astonishing. It requires the quantumn fidelity of physical matter, of reality, with its innate qubit computing capability to derive such possibilities.

It is a game of infinite beauty.


////// end the beautiful game crypto





# Tinker, Tailor, Soldier, Spy 
#Trainer, Coach, Mentor, Consultant


For some, it may come as a surprise that Agile is a noun, not an adjective. Agile with a capital 'A.' 

Other readers will no doubt be familiar with the concept of Agile as a thing, in fact, Agile as an entire industry. Whatever your familiarity or level of experience working with Agile I hope in this chapter to include something new for every reader. Even if only a new perspective on familiar ideas.

At its core Agile, and the myriad of practices associated with the implementation of Agile depend upon a fundamental principle.

Adaptive beats Predictive; every time.

This statement requires some explaining. Allow me to first expand upon it with some basic concepts:

1. It is impossible to predict any future with a hundred percent certainty. No matter how predictable it may be.

2. If you repeatedly invest your time, energy or money based upon the expectation that you can predict the future. At some point, you will be disappointed.

3. The more complicated the circumstances are, the less predictable they are.

4. Circumstances are frequently more complicated than we predicted they would be.

5. Involving people under any circumstances generally complicates those very same circumstances.

6. If you limit investment of your time, energy or money in any endeavor, you will lose less of those things if you wait until you have as much information as possible before doing so.

7. If you doubt any of the above, ask any Physicist, Insurance Broker or Billionaire Casino Owner.

Regarding my last point, an Undertaker may give you a more definitive answer. But, there is always the promise of religion. Likewise, some people never do pay their taxes.

Within Agile there is a universe of terminology and acronyms.  Most of which can trace its etymology to Agile's technical heritage.  It was the geeks who picked up the Agile ball and ran with it. Agile can also trace its roots back to Lean Manufacturing, although the conscious application of Lean Manufacturing principles is a more recent convergence.

What I have tried to do is summarize the concepts at the heart of Agile in a manner any rational person could understand without a technical glossary of terms. We will explore specific practices later in this book, for now, let us explore principles.

Adaptive beats Predictive; every time.

In summary, Agile operates on the principle that it is more efficient to develop products and the technology will deliver those products iteratively. Agile states that there are no economies of scale to be found in predictive resource planning. No matter what those resources may be.

Agile states that it is possible to apply the principle of iterative development to any industry. Agile states that iterative development is particularly suited to the design and delivery of digital or technology products. 

In technology, resources are not primarily physical commodities. In contemporary technical architectures, many teams developing digital products operate at a remove from any need to consider such physical commodities at all, including server infrastructure. 

As an entire industry, we moved to a re-purposed infrastructure. Hardware, which is the physical matter of The Internet has become generic. What we used to call servers, metal boxes, are now called containers. The infrastructure that engineers build upon is predominantly virtual. We call this The Cloud or Cloud Infrastructure.

Physical infrastructure was always the most challenging aspect to plan for when architecting a new digital platform. With physical infrastructure mistakes we immediately apparent and had a visible cost to amend. Capacity planning was also a cause of woe, especially in situations when services were liable to excessive peaks in traffic.

Either you planned your infrastructure to handle peak traffic loads and accept it would sit idle and significantly underutilized for what could be the remaining 364 days of the year. Or, you invested only in what you needed for the majority of the time and accepted during periods of peak traffic things would inevitably fail. I've witnessed both these approaches taken and not always intentionally.

If there ever was an argument for the application of predictive planning in technology it was regarding physical infrastructure.  Moving those infrastructures to The Cloud took that argument away. Or at least outsourced it to the people ultimately responsible for providing the infrastructure upon which the cloud itself runs. Even they are adaptive in their approach to server provision with every individual server being capable of multi-purpose depending upon demand.

Physical infrastructure has become a commodity and available on demand, sometimes by the millisecond. You need only pay for what you use when you use it. 

Scaling that infrastructure to accommodate peak traffic need not be a concern if well designed. The idea that one might provision in advance and maintain infrastructure while it sits idle and awaits use now seems utterly absurd. Technical infrastructures are capable of adapting to demand, on demand.

If The Cloud ended the argument for predictive approaches in the planning of technical architectures, when did the argument for adaptive planning of those same architectures begin? 

When did the Agile vs. Waterfall argument start?

The answer was in August 1970. It began at the Western Electronic Show and Convention in Los Angeles, California. The person who started the argument was a talented computer scientist named Dr. Winston Walker Royce. At that convention Royce submitted a paper entitled:

"MANAGING THE DEVELOPMENT OF LARGE SOFTWARE SYSTEMS[^1]"

There is a reason we can point to this exact point in history as the origin of the Agile vs. Waterfall argument.

In this paper, Royce does not only argue against the use of the Waterfall Model to manage the development of large software systems. By publishing this paper, Royce inadvertently created that very same Waterfall Model. Or at least created the social meme that the Waterfall Model is also even a real thing.

Royce was later accurately quoted, but entirely misrepresented in a paper by T. E. Bell and T. A. Thayer from the TRW Defense and Space Systems Group Redondo Beach, California. In a paper which they submitted to the International Conference on Software Engineering in San Francisco, October 1976.

"SOFTWARE REQUIREMENTS: ARE THEY REALLY A PROBLEM?[^2]"

In writing this book, this is the first recorded quote I have been able to find that refers to Waterfall as a methodology, describes it as a preferred method, and quotes Winston Walker Royce as its author. From this point on that myth seems to have been established:

>"The same top-down approach to a series of requirements statements is explained, without the specialized military jargon, in an excellent paper by Royce; he introduced the concept of the "waterfall" of development activities. In this approach software is developed in the disciplined sequence of activities shown in Figure 2.

!['Figure 2. Implementation steps to develop a large computer program for delivery to a customer.'](./images/body/waterfall.png)

>Each of the documents in the early phases of the waterfall can be considered as stating a set of requirements. At each level a set of requirements serve as the input and a design is produced as output.  This design then becomes the requirements set for the designer at the next level down. 
>
>With so many levels of requirements documents, and with so few software projects mapping nicely into the scheme, we must be more specific about what we mean by the term "software requirements" as used in our studies. We do not mean all the various levels of requirements, but only a single one, one that can usually be identified in large software development projects that have ended successfully. "

As Bell and Thayer describe, in his 'excellent paper' Royce did introduce the concept of the "waterfall" of development activities. What Bell and Thayer misrepresented is that Royce did not support the argument this was a prefered method for developing software. In fact, the whole purpose of Royce's 'excellent paper' was to argue against that exact principle. 


Regarding Figure 2 Royce states:

>*"I believe in this concept, but the implementation described above is risky and invites failure"*

>*"The testing phase which occurs at the end of the development cycle is the first event for which timing, storage, input/output transfers are experienced as distinguished from 
analyzed.'"*

>*"if these phenomena fail to satisfy the various external constraints, then invariably a major redesign is required"*
>
>*"In effect the development process has returned to the origin and one can expect up to a 100-percent overrun in schedule and/or costs."*

He continues to describe what he advocates as a more appropriate method, one that includes iteration and continuous feedback:

!['Figure 3. Hopefully, the iterative interaction between the various phases is confined to successive steps'](./images/body/iterative-steps.png)

!['Figure 4. Unfortunately, for the process illustrated, the design iterations are never confined to the successive steps'](./images/body/iteration-large.png)


>*"Figure 3 portrays the iterative relationship between successive development phases for this scheme."*

>*"Each step progresses and the design is further detailed, there is an iteration with the preceding and succeeding steps"*
>
>*"The virtue of all of this is that as the design proceeds the change process is scoped down to manageable limits."*
>
>*"At any point in the design process after the requirements analysis is completed there exists a firm and close up moving baseline to which to turn in the event of unforeseen design difficulties."*

When you read Royce's white paper, not only do you realize he is arguing against predictive Waterfall planning as a means to manage software development he also describes some of the signature characteristics of Agile software development.

Royce outlines a five-step process. All of which are foundations of Agile development.

STEP 1: PROGRAM DESIGN COMES FIRST

Agile development advocates the production of early working prototypes, as Royce puts it, even at the risk of being wrong.

STEP 2: DOCUMENT THE DESIGN

In Agile development, we produce executable specifications and self-documenting code. Agile coding standards suggest the code itself should be legible to a non-technical observer.

STEP 3: DO IT TWICE

We call this an iteration, as did Royce. The systems we develop are too complex to predict either their behavior or the requirements.

STEP 4: PLAN, CONTROL AND MONITOR TESTING

Testing and test-driven development are critical concepts within Agile development to ensure quality as is the role of Engineer in Test. We bring test planning to the forefront of the design process.

STEP 5: INVOLVE THE CUSTOMER 

Customer collaboration and involvement in product discovery and product design are again entirely aligned with Agile development. So much so, if you do not directly involve your customer, you are arguably not applying Agile.

Royce finally summarizes his vision for managing software development as an iterative process like so :

!['Figure 10, Summary.'](./images/body/royce-summary.png)

Not only did Royce not invent the Waterfall model. If you are seeking to find the first person to summarise the qualities of iterative Agile software development and who then committed those concepts to writing in the arena of public scrutiny. That person probably was Dr. Winston Walker Royce in 1970.

He did so at a time when physical infrastructures were quite literally 'Architectural.' The cost of change to these infrastructures was non-trivial. 
In the 1970s; computer hardware was huge, bespoke and seriously expensive. To give an idea regarding state of the art at the time, the IBM System/370 was announced on June 30 that same year.

!['IBM System370 Mainframe'](./images/body/ibm-system370.jpg)

Physical infrastructure was unmalleable, and mistakes in design were costly. Royce recognized that given the complexity of software solutions, iterative development was an unavoidable fact. The flexibility of modern cloud infrastructure would have been unimaginable. Even in this environment, Royce made the argument for iterative development.

There is no Waterfall Model; it is a myth. The closest thing that approaches a documented waterfall model is the Structured Systems Analysis and Design Method (SSADM) produced by the UK government agency the Central Computer and Telecommunications Agency (CCTA).  

The CCTA is not an organization synonymous with delivering large software systems on time, to an agreed budget, with acceptable quality, or under an approved scope. 

Indeed more associated with the '100-percent overrun in schedule and/or costs' Royce prophesized back in August 1970 for anyone following a predictive Waterfall method to manage software requirements.

If a reader can provide me with genuine evidence that SSADM produced a single working solution architecture, I will happily include that case study in this book as the exception that proved the rule.

There are hundreds of books dedicated to the concept of iterative software development and software development in general. None of them are entitled The Waterfall Method. The Waterfall Method was not designed or published as a thing. No organization ever released The Waterfall Method as a recommended methodology. It is a fallacy.

Agile on the other hand, really is a thing. It became so in February 2001, in The Lodge at the Snowbird ski resort in the Wasatch mountains of Utah.

Between that dates of February 11-13 2001, a group of software methodology geeks came together. Miraculously this group of free-thinking, argumentative geeks reached a consensus. For a group that describes themselves as organizational anarchists that was both accomplishment, and oxymoron. 

The general personality trait that bound all within this group together was to rebel on general principle against anything that one could consider stupidity, institutionalized stupidity in particular. None of these people are shy to express their opinion and then argue the point until the last hair has been thoroughly split.

What this group produced was the Agile Manifesto[^3].

#### Manifesto for Agile Software Development

*We are uncovering better ways of developing software by doing it and helping others do it. Through this work we have come to value:*

*Individuals and interactions over processes and tools.*

*Working software over comprehensive documentation.*

*Customer collaboration over contract negotiation.*

*Responding to change over following a plan.*

#### That is, while there is value in the items on the right, we value the items on the left more.
